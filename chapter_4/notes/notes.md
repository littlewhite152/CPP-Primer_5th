## 基础
一些符号既能作为一元运算符也能作为二元运算符，例如*<br>
在表达式求值得过程中，运算对象常常由一种类型转换成另外一种类型<br>
当一个对象用作右值时，用的是对象的值（内容）<br>
当一个对象用作左值时，用的是对象的身份（在内存中的位置）<br>
如果表达式得求值结果是左值，decltype作用于该表达式得到一个引用类型<br>
decltype(*p)结果是int &<br>
decltype(&p)结果是int **<br>
对于那些没有指定执行顺序的运算符来说，如果表达式并修改了同一个对象，将会引发错误并产生未定义的行为<br>
## 算数运算符
所有的算术运算符都满足左结合律<br>
```
bool b = true;
bool b2 = -b; //布尔值不参与运算，所以b2 = true
```
***c++11新标准：除法运算中规定商一律向0取整***<br>
(-m)/n m/(-n)都等价于-(m/n)<br>
m%(-n)等价于m%n,(-m)%n等价于-(m%n)
## 逻辑和关系运算符
运算符|作用于|返回值
--|:--:|--:
关系运算符|算术类型或指针类型|布尔类型
逻辑运算符|任意能转换成布尔值的类型|布尔类型

**进行比较运算时除非比较的对象是布尔类型，否则不要使用布尔字面值true和false作为运算对象**
## 赋值运算符
`=`<br>
运算符的左侧运算对象必须是一个**可修改**的左值<br>
赋值运算的结果是他的左侧运算对象，并且是个**左值**
## 递增运算符
`++`<br>
前置版本将对象本身作为左值返回，后置版本则将对象原始值的副本作为右值返回<br>
`*p++ //因为优先级关系，等价于*(p++)`<br>
`*p = toupper(*p++) //后面的p++会影响到前面对p的赋值` <br>
## 成员访问运算符
`->`<br>
箭头运算符作用于一个指针类型的运算对象，结果是一个左值<br>
`.`<br>
如果成员所属的对象是左值（右值），那么结果是左值（右值）
## 条件运算符
` ? : `<br>
优先级比较低<br>
`cout << (a < 60) ? "fail" : "pass" //输出1或者0`<br>
`cout << a < 60 ? "fail" : "pass" //错误：试图比较cout和60`<br>
## 位运算符
`~ << >> & ^ |`<br>
**强烈建议仅仅将运算符用于处理无符号类型**
## sizeof运算符
`sizeof（）`<br>
右结合律<br>
所得的值是一个size_t类型<br>
`sizeof(数组) = sizeof(每个成员) * 成员个数`<br>
`sizeof(string对象或者vector对象) = 该类型固定部分的大小`<br>
***c++11新标准：允许使用作用域运算符来获取类成员的大小***
## 逗号运算符
`,`<br>
左结合律
## 类型转换
隐式转换的情况：<br>
+ 在大多数表达式中，比int类型小的整数值首先提升为较大的整数类型
+ 在条件中，非布尔值转换成布尔值
+ 初始化类型中，初始值转换成变量的类型；在赋值语句中，右侧运算对象转换成左侧运算对象的类型
+ 如果算数或关系运算的运算对象有多种类型，需要转换成同一种类型
+ 如果算术运算或关系运算的运算对象有多种类型，需要转换成同一种类型
+ 函数调用的时候也会发生类型转换
### 算术转换
`boorl`,`char`,`signed char`,`unsighed long`,`short`,和`unsighed short`类型的值只要所有可能的值都能存在`int`里面,他们都会提升成`int`类型，否则提升成`unsigned int`类型<br>
a是无符号类型，b是带符号类型，a与b运算的时候，a>=b的情况下，a的类型会转换成b的类型
### 其他隐式类型转换
常量整数值0或者字面值`nullptr`能转换成任意指针类型<br>
指向任意非常量的指针能转换成void*<br>
指向任意对向的指针能转换成`const void*`<br>
允许将指向非常量类型的指针转换成指向相应的常量类型的指针<br>
### 显式转换
命名的强制类型转换格式：`cast-name<type>(expression)`<br>

+ **static_cast**<br>
+ **const_cast**:将常量对象转换成非常量对象<br>
+ **dynamic_cast**:将常量对象转换成非常量对象<br>
+ **reinterpret_cast**<br>

***强制类型转换干扰了正常的类型检查，所以避免使用强制类型转换***<br>
旧时的强制类型转换：<br>
`type(expr) //函数形式的强制类型转换`<br>
`(type)expr //c语言风格的强制类型转换`<br>
## 运算符优先级表